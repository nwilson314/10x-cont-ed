
# Computer Architecture Module (8 Weeks) – Syllabus Overview & Week 1 Plan

## 8-Week Syllabus Overview

1. **Week 1: Bits, Bytes, and Computer Architecture Basics** – Introduction to how programs execute on hardware and how data is represented at the machine level. Covers the journey from high-level code to binary, and fundamental concepts of binary, hex, and two’s complement to build a foundation for the CPU simulator.
2. **Week 2: Machine-Level Programming and Assembly Language** – Dive into assembly language and the machine-level representation of programs. Learn how C/Odin code translates to assembly instructions and build a simple assembler for a hypothetical CPU. This solidifies understanding of instruction formats and prepares for simulating CPU execution.
3. **Week 3: CPU Datapath and Single-Cycle Simulation** – Explore processor datapath components (registers, ALU, memory) and implement a **fetch-decode-execute** cycle. Build a single-cycle CPU simulator (non-pipelined) that can execute a sequence of instructions one at a time. This week sets up the baseline for adding pipelining.
4. **Week 4: Introduction to Pipelining & Instruction Hazards** – Introduce the 5-stage pipeline (IF, ID, EX, MEM, WB) and discuss how pipelining improves throughput. Begin transforming the single-cycle simulator into a pipelined version. Identify pipeline hazards (data, control, structural) and the need for hazard mitigation in a naïve pipeline.
5. **Week 5: Hazard Mitigation and Pipeline Refinement** – Implement solutions for pipeline hazards, such as *operand forwarding* and *pipeline stalls*. Ensure the pipelined CPU simulator correctly handles data dependencies and branch instructions (introducing simple branch prediction or flushing). By the end of this week, the simulator will faithfully model a 5-stage pipelined CPU handling hazards.
6. **Week 6: Cache Memory & Project Integration Planning** – Study the memory hierarchy with focus on L1 caches and how caching improves performance. Build a cache simulator for an L1 cache (configurable size, associativity, replacement policy). Begin planning integration of the cache with the CPU pipeline simulator – i.e., how the pipeline’s memory stage will interface with the cache module.
7. **Week 7: Integrating Pipeline with Cache & System Testing** – Integrate the L1 cache simulation into the pipelined CPU simulator, creating a combined **pipeline-and-cache CPU simulator**. Test the end-to-end system with sample instruction sequences, verifying correctness (ensuring that cache hits/misses affect timing correctly, pipeline stalls on cache misses if modeling that detail). Collect preliminary performance metrics (e.g., CPI with and without cache enabled).
8. **Week 8: Capstone – Performance Evaluation and Optimization** – Finalize the CPU simulator and evaluate its performance. Run comprehensive benchmarks (including programs with varied memory access patterns) to measure the effects of pipelining and caching (e.g., IPC, cache hit rates). Optimize the simulator’s code if needed and ensure clarity of code structure. This week also involves reflective analysis: compare the simulator’s behavior to theoretical expectations (e.g., ideal CPI≈1 for pipelined vs. >1 when stalls occur). Prepare a brief report discussing the design, results, and any optimization techniques applied.

*(Throughout all weeks, the coding tasks can be implemented in **Odin** or C, according to your preference. Odin is a modern, high-performance systems programming language, serving as a friendly alternative to C.)*

---